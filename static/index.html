<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RPub - RSS to EPUB</title>
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <div id="login-overlay" class="hidden">
        <div id="login-box">
            <h2>Login Required</h2>
            <form id="login-form">
                <input type="text" id="username" placeholder="Username" required />
                <input type="password" id="password" placeholder="Password" required />
                <button type="submit">Login</button>
            </form>
            <p id="login-error" style="color: red"></p>
        </div>
    </div>
    <div class="container hidden">
        <header>
            <h1>RPub</h1>
            <p>RSS Aggregator & EPUB Generator</p>
        </header>

        <main>
            <!-- Feeds Section -->
            <section id="feeds-section">
                <h2>Feeds</h2>
                <ul id="feeds-list" class="item-list"></ul>
                <form id="add-feed-form">
                    <input type="url" name="url" placeholder="Feed URL" required />
                    <input type="text" name="name" placeholder="Name (Optional)" />
                    <input type="number" name="concurrency_limit" placeholder="Limit (0=Unl)" min="0"
                        style="width: 100px" />
                    <button type="submit">Add Feed</button>
                </form>
            </section>

            <hr />

            <!-- Schedules Section -->
            <section id="schedules-section">
                <h2>Schedules</h2>
                <ul id="schedules-list" class="item-list"></ul>
                <form id="add-schedule-form">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <select name="hour" required style="padding: 5px;">
                            <option value="" disabled selected>Hour</option>
                            <script>
                                for (let i = 0; i < 24; i++) {
                                    const val = i.toString().padStart(2, '0');
                                    document.write(`<option value="${val}">${val}</option>`);
                                }
                            </script>
                        </select>
                        :
                        <select name="minute" required style="padding: 5px;">
                            <option value="" disabled selected>Min</option>
                            <script>
                                for (let i = 0; i < 60; i += 5) {
                                    const val = i.toString().padStart(2, '0');
                                    document.write(`<option value="${val}">${val}</option>`);
                                }
                            </script>
                        </select>

                        <select name="timezone" id="timezone-select" required style="padding: 5px; max-width: 200px;">
                            <option value="" disabled selected>Timezone</option>
                        </select>
                    </div>
                    <div style="margin-top: 10px;">
                        <button type="submit">Add Schedule</button>
                    </div>
                </form>
                <p class="hint">
                    Selected time will be converted to GMT for the scheduler.
                </p>
            </section>

            <hr />

            <!-- Generate Section -->
            <section id="generate-section">
                <h2>Manual Generation</h2>
                <button id="generate-btn">Generate EPUB Now</button>
                <div id="status"></div>
            </section>

            <hr />

            <!-- Cover Image Section -->
            <section id="cover-section">
                <h2>Cover Image</h2>
                <div class="cover-wrapper">
                    <div class="current-cover">
                        <h3>Current Cover</h3>
                        <!-- Add timestamp to bust cache -->
                        <img id="cover-preview" src="/cover.jpg" alt="Book Cover"
                            style="max-width: 200px; border: 1px solid #ccc" />
                    </div>
                    <div class="upload-cover">
                        <h3>Replace Cover</h3>
                        <form id="upload-cover-form">
                            <input type="file" id="cover-file" name="cover" accept="image/jpeg" required />
                            <button type="submit">Upload New Cover</button>
                            <div id="upload-status"></div>
                        </form>
                    </div>
                </div>
            </section>

            <hr />

            <!-- Downloads Section -->
            <section id="downloads-section">
                <h2>Downloads</h2>
                <ul id="downloads-list" class="item-list"></ul>
            </section>
        </main>
    </div>

    <script>
        let authHeader = localStorage.getItem("rpub_auth");

        // Populate Timezones
        const timezoneSelect = document.getElementById('timezone-select');
        const timezones = Intl.supportedValuesOf('timeZone');
        timezones.forEach(tz => {
            const opt = document.createElement('option');
            opt.value = tz;
            opt.textContent = tz;
            if (tz === Intl.DateTimeFormat().resolvedOptions().timeZone) {
                opt.selected = true;
            }
            timezoneSelect.appendChild(opt);
        });

        // API Helpers
        async function api(url, method = "GET", body = null) {
            const headers = { "Content-Type": "application/json" };
            if (authHeader) {
                headers["Authorization"] = authHeader;
            }

            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);

            const res = await fetch(url, options);

            if (res.status === 401) {
                showLogin();
                throw new Error("Unauthorized");
            }

            if (!res.ok) throw new Error(await res.text());
            return res.json().catch(() => { });
        }

        function showLogin() {
            document
                .getElementById("login-overlay")
                .classList.remove("hidden");
            document.querySelector(".container").classList.add("hidden");
        }

        function hideLogin() {
            document
                .getElementById("login-overlay")
                .classList.add("hidden");
            document.querySelector(".container").classList.remove("hidden");
        }

        async function handleLogin(e) {
            e.preventDefault();
            const u = document.getElementById("username").value;
            const p = document.getElementById("password").value;
            const creds = "Basic " + btoa(u + ":" + p);

            try {
                // Verify credentials
                const res = await fetch("/auth/check", {
                    headers: { Authorization: creds },
                });

                if (res.ok) {
                    authHeader = creds;
                    localStorage.setItem("rpub_auth", creds);
                    hideLogin();
                    // Reload data
                    loadFeeds();
                    loadSchedules();
                    loadDownloads();
                } else {
                    document.getElementById("login-error").textContent =
                        "Invalid credentials";
                }
            } catch (err) {
                document.getElementById("login-error").textContent =
                    "Login failed";
            }
        }

        // Feeds
        async function loadFeeds() {
            try {
                const feeds = await api("/feeds");
                const list = document.getElementById("feeds-list");
                list.innerHTML = feeds
                    .map(
                        (f) => `
                    <li>
                        <span>${f.name || f.url} <small>(${f.concurrency_limit === 0 ? "Unlimited" : f.concurrency_limit + " threads"})</small></span>
                        <button onclick="deleteFeed(${f.id})" class="delete-btn">×</button>
                    </li>
                `,
                    )
                    .join("");
            } catch (e) {
                console.error(e);
            }
        }

        async function addFeed(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            await api("/feeds", "POST", {
                url: formData.get("url"),
                name: formData.get("name") || null,
                concurrency_limit: parseInt(
                    formData.get("concurrency_limit") || "0",
                    10,
                ),
            });
            e.target.reset();
            loadFeeds();
        }

        async function deleteFeed(id) {
            if (confirm("Delete this feed?")) {
                await api(`/feeds/${id}`, "DELETE");
                loadFeeds();
            }
        }

        // Schedules
        async function loadSchedules() {
            try {
                const schedules = await api("/schedules");
                const list = document.getElementById("schedules-list");

                function formatCron(cron) {
                    try {
                        const parts = cron.split(' ');
                        // Check for standard format: 0 min hour * * *
                        if (parts.length >= 5 && parts[0] === '0' && parts[3] === '*' && parts[4] === '*' && parts[5] === '*') {
                            const minute = parseInt(parts[1], 10);
                            const hour = parseInt(parts[2], 10);

                            // Create Date in UTC
                            const date = new Date();
                            date.setUTCHours(hour, minute, 0, 0);

                            // Format to local time
                            return new Intl.DateTimeFormat('default', {
                                hour: 'numeric',
                                minute: 'numeric',
                                timeZoneName: 'short'
                            }).format(date);
                        }
                    } catch (e) {
                        console.error("Error parsing cron", e);
                    }
                    return cron;
                }

                list.innerHTML = schedules
                    .map(
                        (s) => `
                    <li>
                        <span>${formatCron(s.cron_expression)}</span>
                        <button onclick="deleteSchedule(${s.id})" class="delete-btn">×</button>
                    </li>
                `,
                    )
                    .join("");
            } catch (e) {
                console.error(e);
            }
        }

        async function addSchedule(e) {
            e.preventDefault();
            const formData = new FormData(e.target);

            const hour = parseInt(formData.get("hour"), 10);
            const minute = parseInt(formData.get("minute"), 10);
            const timezone = formData.get("timezone");

            if (isNaN(hour) || isNaN(minute) || !timezone) {
                alert("Please select Hour, Minute, and Timezone.");
                return;
            }

            // Convert to GMT
            // Create a date object for "today" at the selected time in the selected timezone
            // We use a trick: parse a string with the timezone offset, or use Intl to shift it.
            // Simpler: Use a temporary Date object, set it to the target time in the target TZ? 
            // JS Date is always local or UTC. 
            // Strategy: Get the UTC timestamp for the chosen time in the chosen zone.

            // 1. Get current date components
            const now = new Date();

            // 2. Format a string for the target time in the target zone, e.g. "2023-10-27T10:00:00"
            // But passing this to Date() constructor uses local time.

            // We can use toLocaleString logic to find the offset, but it's tricky.
            // Alternative: 
            // Construct a date that we *think* is the time, then check what time it is in that zone, and adjust.

            // Let's use a robust approach:
            // We want to find a UTC time T such that T in 'timezone' is 'hour:minute'.
            // Start with T = now (with hours/mins set to hour/minute in UTC).
            // Check what time T is in 'timezone'. 
            // Calculate difference and apply.

            const targetHour = hour;
            const targetMinute = minute;

            // Start a guess at the current UTC date, with the target time imposed as if it were UTC
            let guess = new Date();
            guess.setUTCHours(targetHour, targetMinute, 0, 0);

            // Function to get the hour/minute of a Date in the target timezone
            function getTimeInZone(date, zone) {
                const parts = new Intl.DateTimeFormat('en-US', {
                    timeZone: zone,
                    hour: 'numeric',
                    minute: 'numeric',
                    hour12: false
                }).formatToParts(date);

                const h = parseInt(parts.find(p => p.type === 'hour').value, 10);
                const m = parseInt(parts.find(p => p.type === 'minute').value, 10);
                // Handle 24:00 wrap if any
                return { h: h === 24 ? 0 : h, m };
            }

            // Iterate to converge (usually takes 1 or 2 steps)
            for (let i = 0; i < 3; i++) {
                const currentInZone = getTimeInZone(guess, timezone);

                let diffMinutes = (targetHour - currentInZone.h) * 60 + (targetMinute - currentInZone.m);

                // Handle day wrap cases roughly (e.g. target 00:00 vs current 23:00 is +1 hr, not -23)
                if (diffMinutes > 720) diffMinutes -= 1440;
                if (diffMinutes < -720) diffMinutes += 1440;

                if (diffMinutes === 0) break;

                guess.setTime(guess.getTime() + diffMinutes * 60 * 1000);
            }

            // Now 'guess' is the UTC time that corresponds to the user's selected time in the selected timezone.
            const utcHour = guess.getUTCHours();
            const utcMinute = guess.getUTCMinutes();

            const cronExpression = `0 ${utcMinute} ${utcHour} * * *`; // Seconds Minutes Hours ...

            await api("/schedules", "POST", {
                cron_expression: cronExpression,
            });

            // We don't reset form fully because timezone/time selection might be sticky desired behavior, 
            // but standard simple form reset is fine.
            // e.target.reset(); // Resetting clears the timezone selection too which is annoying.
            // Let's just keep it or maybe just reset standard way. User can change it back.

            loadSchedules();
        }

        async function deleteSchedule(id) {
            if (confirm("Delete this schedule?")) {
                await api(`/schedules/${id}`, "DELETE");
                loadSchedules();
            }
        }

        // Downloads
        async function loadDownloads() {
            try {
                const files = await api("/downloads");
                const list = document.getElementById("downloads-list");
                list.innerHTML = files
                    .map(
                        (f) => `
                    <li>
                        <a href="/epubs/${f}" download>${f}</a>
                    </li>
                `,
                    )
                    .join("");
            } catch (e) {
                console.error(e);
            }
        }

        // Generate
        async function generate() {
            const btn = document.getElementById("generate-btn");
            const status = document.getElementById("status");
            btn.disabled = true;
            status.textContent = "Requesting generation...";

            try {
                const res = await fetch("/generate", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        ...(authHeader
                            ? { Authorization: authHeader }
                            : {}),
                    },
                    body: JSON.stringify({ feeds: [] }), // Empty list triggers DB fetch
                });

                if (res.ok) {
                    status.textContent =
                        "Generation started in background. Please wait...";
                    // Poll for new downloads every 2 seconds for a while
                    let checks = 0;
                    const interval = setInterval(async () => {
                        checks++;
                        await loadDownloads();
                        if (checks > 10) {
                            // Stop auto-refreshing after 20 seconds
                            clearInterval(interval);
                            status.textContent =
                                "Generation started. Check downloads list below.";
                        }
                    }, 2000);
                } else if (res.status === 401) {
                    showLogin();
                    status.textContent = "Authentication required.";
                } else {
                    status.textContent = "Error: " + (await res.text());
                }
            } catch (e) {
                status.textContent = "Error: " + e.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function uploadCover(e) {
            e.preventDefault();
            const form = e.target;
            const status = document.getElementById("upload-status");
            const fileInput = document.getElementById("cover-file");

            if (fileInput.files.length === 0) return;

            const formData = new FormData();
            formData.append("cover", fileInput.files[0]);

            status.textContent = "Uploading...";

            try {
                // Manually construct fetch to handle FormData with Auth
                const headers = {};
                if (authHeader) headers["Authorization"] = authHeader;
                // do NOT set Content-Type header when sending FormData, let browser set it with boundary

                const res = await fetch("/cover", {
                    method: "POST",
                    headers: headers,
                    body: formData,
                });

                if (res.ok) {
                    status.textContent = "Cover updated successfully!";
                    status.style.color = "green";
                    // Refresh image with timestamp
                    document.getElementById("cover-preview").src =
                        "/cover.jpg?t=" + new Date().getTime();
                    form.reset();
                } else if (res.status === 401) {
                    showLogin();
                    status.textContent = "Authentication required.";
                    status.style.color = "red";
                } else {
                    status.textContent = "Error: " + (await res.text());
                    status.style.color = "red";
                }
            } catch (err) {
                status.textContent = "Error: " + err.message;
                status.style.color = "red";
            }
        }

        // Check Auth on Init
        async function checkAuth() {
            try {
                await api("/auth/check");
                // If success, load data and show container
                document
                    .querySelector(".container")
                    .classList.remove("hidden");
                loadFeeds();
                loadSchedules();
                loadDownloads();
            } catch (e) {
                // api() handles 401 by showing login
            }
        }

        // Init
        document
            .getElementById("login-form")
            .addEventListener("submit", handleLogin);
        document
            .getElementById("add-feed-form")
            .addEventListener("submit", addFeed);
        document
            .getElementById("add-schedule-form")
            .addEventListener("submit", addSchedule);
        document
            .getElementById("add-schedule-form")
            .addEventListener("submit", addSchedule);
        document
            .getElementById("generate-btn")
            .addEventListener("click", generate);
        document
            .getElementById("upload-cover-form")
            .addEventListener("submit", uploadCover);

        checkAuth();
    </script>
</body>

</html>